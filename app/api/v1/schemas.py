from pydantic import BaseModel, Field
from typing import List, Optional, Any, Dict

class DocumentUploadResponse(BaseModel):
    filename: str
    message: str
    doc_id: str # Unique ID for the uploaded document (could be filename or internal ID)
    session_id: str

class Chunk(BaseModel):
    text: str
    page_number: Optional[int] = None
    source_document: str

class SearchResultItem(BaseModel):
    chunk: Chunk
    score: float
    id: Optional[str] = None # Pinecone ID of the vector

class SearchResponse(BaseModel):
    results: List[SearchResultItem]
    query_id: str # To track context (can be generated by service)
    session_id: str

class QueryRequest(BaseModel):
    query: str
    session_id: str
    top_k: int = 3
    # previous_query_id: Optional[str] = None # Langchain memory handles this implicitly

class QAQueryRequest(BaseModel):
    question: str
    session_id: str

class QAResponse(BaseModel):
    question: str
    answer: str
    source_chunks: List[Chunk] # Chunks used to derive the answer
    session_id: str

class FeedbackRequest(BaseModel):
    session_id: str
    query_id: str # ID of the query that produced the result
    result_id: str # Pinecone ID of the chunk
    relevance_score: int # e.g., 1 for relevant, 0 for not relevant

class FeedbackResponse(BaseModel):
    message: str
    feedback_id: str

class EmbeddingsDataResponse(BaseModel):
    embeddings: List[List[float]]
    chunks_metadata: List[Dict[str, Any]] # list of dicts like {'text': ..., 'page_number': ..., 'source_document': ...}